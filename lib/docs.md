# LampJs Documentation

LampJs is a lightweight framework meant to simplify the process of building a highly efficient reactive frontend.

## When to use LampJs

LampJs is made for developers who want a lightweight, efficient, and flexible framework.

## Getting Started

Start by using your package manager of choice to create a lampjs-app template (npm and pnpm examples are shown)

pnpm:

```sh
pnpm create lampjs-app
```

npm:

```sh
npx create-lampjs-app
```

Continue by following the instructions in the cli

## Project Structure

- `public`
  - For assets
- `src`
  - Where the magic happens
  - `contexts`
    - Place to keep global state variables
  - `components`
    - Place to keep all components
  - `pages`
    - For organizing the page components for the app
    - Not for client side routing (shown later)
  - `main.tsx`
    - Main entry point for the app
- `index.html`
  - Root html page for the application
  - LampJs is a spa framework

## Components

Components in LampJs are similar to components in React or SolidJs. It is a function that returns jsx.

Example:

```tsx
const Counter = () => {
  const count = createState(0);

  return <button onClick={() => count((prev) => prev + 1)}>Count is {num()}</button>;
};
```

## State

For simplicity and the fact that not much else is needed, there is only one utility function for managing state: `createState`.

The `createState` function returns a function that returns a "state object" with all the necessary tools to manage the state and effects yourself if you need to.

When calling the function returned by `createState` in the UI (for example in the counter): `{num()}`, LampJs will make a reactive node on the page that updates when the state updates.

To get the current value of the state in the javascript, call the function and get the value property

```typescript
const state = createState(0);
const currentState = state().value;
```

To update a state variable, call the function with a new value, or use the callback to use the current value easier.

```typescript
const state = createState(0);

// set state to 1
state(1);

// increment state
state(state().value + 1);

// increment state again
state((prev) => prev + 1);
```

LampJs state is based on signals to be as efficient as possible. The function is lightweight so don't feel bad if you use it a lot.

The `createState` function in LampJs in unique because it is not bound to a component, meaning that you can initialize state wherever you want. You can create a state variable in a new file and export it, and it can be imported into any component you want, effectively creating a context.

The `reactive` api can be used to render a chunk of jsx when a state variable changes.

Example:

```tsx
const obj = createState({
  name: 'John',
  age: '21'
});

return (
  <div>
    {reactive(
      (obj) => (
        <span>
          {obj.name}&nbsp;{obj.age}
        </span>
      ),
      [obj()]
    )}
  </div>
);
```

The reactive function takes two parameters, the first is a callback, and the second is the list of state variables to re-render when they change. The parameters of the callback are the list of the state variables in the order they were provided (type safety is preserved).

To make iterating a reactive array easier, you can use the `For` element. The `each` property is the array state variable, and the children of the component is a function that is ran for each item in the array to render it. The elements are rendered in a list in the parent component. The for element has one property `each` which is a state variable of the array to loop reactively. You must also provide a callback as the child of the component to tell the framework how to render each element. The callback has two parameters, the first is the item as a state variable generated by LampJs, and the other is the index that is also a state variable generated by LampJs.

Example:

```tsx
const arr = createState([1, 2, 3]);

return (
  <For each={arr()}>
    {(item, index) => (
      <div>
        <span>
          {item()} - {index()}
        </span>
        <span>something else</span>
      </div>
    )}
  </For>
);
```

To make rendering conditional content easier, you can use the `If` component.

Example:

```tsx
const bool = createState(true);

return (
  <If
    condition={bool()}
    then={<span>Showing!</span>}
    else={<span>Not showing :(</span>}
  />
);
```

The `If` component has three properties, the `condition` prop is the state variable to track, the `then` prop is the content to show when the value is true, and the `else` prop is what to show when the content is false.

## Router

A framework wouldn't be complete without a router. The LampJs router is similar to the one in vue, import the Router element and provide it with an object describing the route structure.

Example:

```tsx
// define the routes
const routes = [
  {
    path: '/',
    element: <Root />
  },
  {
    path: '/about',
    element: <About />
  }
];

// use Router element
<Router routes={routes} />;
```

The Router element does not replace the whole screen content, only the place where it is located. That means that you can have the Router element nested within your component tree.

To link to other pages within the site, use the `Link` component. The `a` component will work, but it will make do a whole page reload every time.

## Effects

Effects in LampJs are simple to create. Simply pass the state variable function into the `createEffect` function.

Example:

```typescript
const count = createState(0);

createEffect(() => {
  console.log(count().value);
}, [count()]);
```

In this example every time `count` is updated, the effect will run and the current value of count will be printed.

## Misc

**Mounting the application**

The `mount` function is used to mount a component of your choice to an element of your choice, in the `create-lampjs-template`, the boilerplate uses `document.body` as the root node to mount to, and a `Router` element to mount.

The `onPageMount` function runs once after the dom is rendered initially. This is used when you want to query an element and be sure it has been mounted on the page.

**Render Cycle and Element References**

Each component function is only called once when it is mounted, and again if it gets mounted again. This means that you are free to use vanilla element query apis such as `getElementById` or `querySelectorAll` to query for your dom elements.

**Types**

Typesafety is handled mostly in the framework, There are only a few types you will have to manage yourself.

A state variable for a string would look like this:

```typescript
type MyType = State<string>;
```

This type is primarily useful for taking state variables as properties to a component, and would look like this to use.

```tsx
<Component prop={state} />
```

You are also able to use the `Reactive` class type to specify a reactive variable, the difference is you must call the state function for it to be valid:

```tsx
<Component prop={state()} />
```

The difference between the two is where in the `State` method, you pass the function to the state so it can be updated using that api, in the `Reactive` one, you would be required to use the lower level state apis.

If you are developing a library that takes state variables, prefer to use `Reactive` rather than `State` for consistency.

**Import Aliases**

Import aliases specified by adding them in the `aliases.ts` file in the root project directory. This file exports an object where the key is the new alias and the value is the relative path to the directory. Before the alias is computed a `@` is placed before so a key that is "test" would be aliased as "@test".

The `@` alias is available by default pointing to the `src` directory
